// 2025-11-12 00:07:16
#event properties (no comments/etc. here are saved)
parent_index = -1;
sprite_index = spr_object_settings;
uses_physics = false;

#event create
enum CUR_EDITING
{
	NONE,
	OBJECT,
	OPTIONS, // add subctg?
	LEVEL_META
}

state = CUR_EDITING.NONE;

editor_object = noone;

valid_editor_object = editor_object;

_manager = instance_find(manager,0);

inp_depth = depth - 1;

//movable customizable object in the playing field to make editing easyer

inp_objects_settings = [
//   return_key,  x,    y,                            leng, numb, xscale, parent
	["time",   x + 90,  y + sprite_height * 1/15 + 40,  5,  true,  1, id],	
	["name",   x + 90,  y + sprite_height * 1/15 + 70,  25, false, 3.2, id],	
	["pos_x",  x + 135, y + sprite_height * 1/3 +  40,  4,  true,  1, id],	
	["pos_x",  x + 230, y + sprite_height * 1/3 +  40,  4,  true,  1, id],
	["size_x", x + 135, y + sprite_height * 1/3 +  70,  3,  true,  1, id],	
	["size_y", x + 230, y + sprite_height * 1/3 +  70,  3,  true,  1, id],	
	["angle",  x + 135, y + sprite_height * 1/3 +  100, 3,  true,  1, id]	
];

objects = [];

live_obj = noone;
for (var o = 0; o < array_length(inp_objects_settings); o++)
{
	var obj_data = inp_objects_settings[o];
	var obj = instance_create_depth(obj_data[1],obj_data[2],inp_depth,obj_input_field);
	obj.visible = false;
	obj.image_xscale = obj_data[5];
	obj.max_text_lenght = obj_data[3];
	obj.only_numbers = obj_data[4];
	obj._parent = obj_data[6];
	obj.return_key = obj_data[0];
	obj.image_yscale = 0.9;

	objects[o] = obj;
}

// creating object for meta editing

var edit_man = instance_find(manager_editor,0);

inp_meta_data = [
	["id",   x + 100,  y + sprite_height * 1/15 + 40,  9,  true,  1.3,  edit_man], // do we want user to be able and edit ids?
	["name", x + 100,  y + sprite_height * 1/15 + 70,  25, false, 2.75, edit_man],
	["desc", x + 100,  y + sprite_height * 1/15 + 100, 25, false, 2.75, edit_man],
	["leng", x + 100,  y + sprite_height * 1/15 + 130, 5,  true,  1,    edit_man],	
	["diff", x + 100,  y + sprite_height * 1/15 + 160, 5,  true,  1,    edit_man]
];

metas = [];

for (var o = 0; o < array_length(inp_meta_data); o++)
{
	var meta_obj = inp_meta_data[o];
	var obj = instance_create_depth(meta_obj[1],meta_obj[2],inp_depth,obj_input_field);
	obj.visible = false;
	obj.image_xscale = meta_obj[5];
	obj.max_text_lenght = meta_obj[3];
	obj.only_numbers = meta_obj[4];
	obj._parent = meta_obj[6];
	obj.return_key = meta_obj[0];
	obj.image_yscale = 0.9;

	
	metas[o] = obj;
		
}

set_data = [];

show_debug_message($"objs: {array_length(objects)} meta: {array_length(metas)}");

#event step automaticly check and toggle input box visibility
function update_inputbox_visibility() {
    var obj_len  = array_length(objects);
    var meta_len = array_length(metas);

    var show_objects = (state == CUR_EDITING.OBJECT);
    var show_metas   = (state == CUR_EDITING.LEVEL_META);

    // object inputs
    for (var i = 0; i < obj_len; i++) {
        objects[i].visible = show_objects;
    }

    // meta inputs
    for (var i = 0; i < meta_len; i++) {
        metas[i].visible = show_metas;
    }
}


if (state == CUR_EDITING.LEVEL_META)
{
	for (var i = 0; i < array_length(metas);i++)
	{
		metas[i].visible = true;
	}

} else if (state == CUR_EDITING.OBJECT)
{
	if (array_length(set_data) != 0)
	{
	
		switch (set_data[0])
		{
			case "time":
				valid_editor_object.object_time = set_data[1];
					break;
			case "name":
				valid_editor_object.object_name = set_data[1];
					break;
			case "pos_x":
				valid_editor_object.object_position[0] = set_data[1];
					break;
			case "pos_y":
				valid_editor_object.object_position[1] = set_data[1];
					break;
			case "size_x":
				valid_editor_object.object_size[0] = set_data[1];
					break;
			case "size_y":
				valid_editor_object.object_size[1] = set_data[1];
					break;
			case "angle":
				valid_editor_object.object_angle = set_data[1];
					break;
			default:
				show_debug_message($"wrong key: {set_data[0]}");
					break;
		}
	
		show_debug_message($"updated {set_data[0]} with {set_data[1]}");
	
		set_data = [];	
	}
}else if (state == CUR_EDITING.OPTIONS)
{
	
}


// CUR_EDITING.OBJECT
if (mouse_check_button_pressed(mb_left))
{
	editor_object = instance_position(mouse_x,mouse_y,obj_editor_enemy); 

	if (editor_object != -4)
	{

		state = CUR_EDITING.OBJECT;
		
		valid_editor_object = editor_object;
		
		for (var i = 0; i < array_length(objects); i++) {
		    var obj = objects[i];
		    
		    obj.visible = true;
		    
		    var key = obj.return_key;
		    
		    var def_value = "";
		    
		    switch (key)
		    {
		    	case "time":
		    		def_value = valid_editor_object.object_time;
	    		break;
		    	
		    	case "name":
		    		def_value = valid_editor_object.object_name;
		    	break;
		    	
		    	case "pos_x":
		    		def_value = valid_editor_object.object_position[0];
		    	break;
		    	
		    	case "pos_y":
			    	def_value = valid_editor_object.object_position[1];
		    	break;
		    	
		    	case "size_x":
					def_value = valid_editor_object.object_size[0];
		    	break;
		    	
		    	case "size_y":
		    		def_value = valid_editor_object.object_size[1];
		    	break;
		    	
    		 	case "angle":
    		 		def_value = valid_editor_object.object_angle;
		    	break;
		    	
		    	default:
		    		def_value = "default";
	    		break;
		    	
		    }
		    
		    obj.t_ = def_value;
		    obj.text = def_value;
		    obj.default_var = def_value;
		}
	}else
	{
		editor_object = valid_editor_object;
	}
}

update_inputbox_visibility();

// show_debug_message($"state: {state}");
// show_debug_message($"bool: {state == CUR_EDITING.OBJECT}");

#event draw_gui
if (live_call()) return live_result;

if (state == CUR_EDITING.OBJECT)
{

	if (editor_object != noone)
	{
		draw_set_valign(fa_middle);
		draw_set_halign(fa_left);
		draw_set_color(c_white);
	
		draw_text_transformed(x + 25, y + sprite_height * 1/15,"General",1.75,1.75,0);
		draw_line_color(x  + 25, y + sprite_height * 1/15 + 15,x  + string_width("General") * 2.5, y + sprite_height * 1/15 + 15,c_gray,c_gray);
		draw_text_transformed(x + 25, y + sprite_height * 1/15 + 40,$"Time: ",1.25,1.25,0);
		draw_text_transformed(x + 25, y + sprite_height * 1/15 + 70,$"Name: ",1.25,1.25,0);
	
		//transformation
	
		draw_set_valign(fa_middle);
		draw_set_halign(fa_left);
		draw_set_color(c_white);
	
		draw_text_transformed(x + 25, y + sprite_height * 1/3,"Transformations",1.75,1.75,0);
		draw_line_color(x  + 25, y + sprite_height * 1/3 + 15,x  + string_width("Transformations") * 2.1, y + sprite_height * 1/3 + 15,c_gray,c_gray);
		draw_text_transformed(x + 25, y + sprite_height * 1/3 + 40,$"Position: W            H",1.25,1.25,0);
		draw_text_transformed(x + 25, y + sprite_height * 1/3 + 70,$"Size:       W            H",1.25,1.25,0);
		draw_text_transformed(x + 25, y + sprite_height * 1/3 + 100,$"Angle:",1.25,1.25,0);
	}
}else if (state == CUR_EDITING.LEVEL_META)
{
		draw_set_valign(fa_middle);
		draw_set_halign(fa_left);
		draw_set_color(c_white);
	
		draw_text_transformed(x + 25, y + sprite_height * 1/15,"Meta",1.75,1.75,0);
		draw_line_color(x  + 25, y + sprite_height * 1/15 + 15,x  + string_width("Meta") * 2.5, y + sprite_height * 1/15 + 15,c_gray,c_gray);
		draw_text_transformed(x + 25, y + sprite_height * 1/15 + 40,$"Id: ",1.25,1.25,0); // should the user be able to edit this?
		draw_text_transformed(x + 25, y + sprite_height * 1/15 + 70,$"Name: ",1.25,1.25,0);
		draw_text_transformed(x + 25, y + sprite_height * 1/15 + 100,$"Desc: ",1.25,1.25,0);
		draw_text_transformed(x + 25, y + sprite_height * 1/15 + 130,$"Leng: ",1.25,1.25,0); // calc automaticly i guess?
		draw_text_transformed(x + 25, y + sprite_height * 1/15 + 160,$"Diff: ",1.25,1.25,0); // -//-
}
