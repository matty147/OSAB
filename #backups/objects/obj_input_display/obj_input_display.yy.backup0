// 2025-12-20 17:03:09
#event properties (no comments/etc. here are saved)
parent_index = -1;
sprite_index = spr_input_map_display;
uses_physics = false;

#event create

enum INPUT_METHODS {
    KEYBOARDS,
    CONTROLLER,
}

input_map_max = 4;

short_key = vk_multiply;

wait = 0;

already_added_con = [];
already_added_key = [];

player = instance_find(obj_player,1);

if (level == room)
{
    visible = false;
}

image_yscale = 3;

image_xscale = 0;

y = room_height - sprite_height;

#event step
// if (live_call()) return live_result;

if (array_length(global.input_map) > 0) // this code is used to change the size of the object based on the amount of controllers are conected
{
	var xscale = (32 + clamp(array_length(global.input_map) + 1,4,4) * 74) / sprite_get_width(sprite_index);
}else xscale = (32 + 74 * 4) / sprite_get_width(sprite_index);;

image_xscale += (xscale - image_xscale) * 0.1;

if (keyboard_check_pressed(ord("P")))
{
    global.input_map = [];
    already_added_con = [];
    already_added_key = [];
}

if (array_length(global.gamepads) > 0)
{
    for (var c = 0; c < array_length(global.gamepads);c++)
    {
        if (gamepad_button_check_pressed(global.gamepads[c],gp_face1))
        {
            show_debug_message($"aaa {c} vs {global.gamepads[c]}");
            
            if (array_length(global.input_map) < 4 && !array_contains(already_added_con,c))
            {
            	audio_play_sound(snd_player_join,1,false);
                array_push(global.input_map,[INPUT_METHODS.CONTROLLER,global.gamepads[c]]);
                array_push(already_added_con,c);
            }
        }
    }
}

if (array_length(global.input_map) < 4)
{
    if (keyboard_check_pressed(vk_space))
    {
        array_push(global.input_map,INPUT_METHODS.KEYBOARDS); // tf should i do here?
        audio_play_sound(snd_player_join,1,false);
    }
}

#event async_system controller manager
if (async_load[? "event_type"] == "gamepad discovered")
{
    var _pad = async_load[? "pad_index"];
    gamepad_set_axis_deadzone(_pad, 0.2);
    array_push(global.gamepads, _pad);
    
    show_debug_message($"conected: {_pad} {gamepad_get_description(_pad)}");
}
else if (async_load[? "event_type"] == "gamepad lost")
{
    var _pad = async_load[? "pad_index"];
    var _index = array_get_index(global.gamepads, _pad);
    array_delete(global.gamepads, _index, 1);
}

#event draw_gui
// if (live_call()) return live_result;

//shift the object a bit lower so i dont need to fix this crap
y += 15;

// ghosts
for (var i = 0; i < 4;i++)
{
	if (i >= array_length(global.input_map) && position_meeting(x + (i * 74 + 16) + 48,y,id))
	{
		if (array_length(global.gamepads) > 0)
		{
	    	sprite = (floor((global.runtime) / 30) % 2 == 0) ? spr_keyboard_icon : spr_controller_icon;
		}else sprite = spr_keyboard_icon;
		
		draw_sprite_ext(sprite, 0, x + (i * 74 + 16), y,1,1,0,c_white,0.5);
		draw_text_color(x + (i * 74 + 16) + 32,y + 67 ,$"P{i + 1}",c_white,c_white,c_white,c_white,1);
	}
}

// real
for (var i = 0; i < array_length(global.input_map);i++)
{
	if (position_meeting(x + (i * 74 + 16) + 48,y,id))
	{
	    var input = global.input_map[i];
	    
	    if (is_array(input))
	    {
	    	input = input[0];
	    }
	    
	    var sprite = Sprite76;
	    
	    switch (input)
	    {
	        case INPUT_METHODS.KEYBOARDS:
	                sprite = spr_keyboard_icon;
	            break;
	        
	        case INPUT_METHODS.CONTROLLER:
	                sprite = spr_controller_icon;
	            break;
	    }
	    
		draw_sprite_ext(sprite, 0, x + (i * 74 + 16), y,1,1,0,c_white,1);
		draw_text_color(x + (i * 74 + 16) + 32,y + 67 ,$"P{i + 1}",c_white,c_white,c_white,c_white,1);

	}
}

if (array_length(global.input_map) <= 4) // todo make this more visible / better text
{
		draw_text_transformed_color(x + (clamp((array_length(global.input_map) + 1),1.6,1.6)* 74 + 16) + 32,y,"Press [SPACE] button or the [A] button to join",0.9,0.9,0,c_white,c_white,c_white,c_white,1);
}

y -= 15;
